        let sortArr = [7,10,9,1,3]
        
        print(self.insertSort(origin: sortArr))
        
        print(self.selectSort(origin: sortArr))
        
        print(self.bubbleSort(origin: sortArr))
        
        print(self.quickSort(arr: sortArr))
        
        print(self.mergeSort(arr: sortArr))
    
    
    //삽입정렬 왼쪽으로 기준으로 오른쪽의 전체에서 가장 작은 값을 찾아 왼쪽으로 보내는것
    func insertSort<T:Comparable>(origin:[T]) -> [T]{
        var copyArr = origin
        for i in 0..<copyArr.count-1{
            var minIndex = i
            for j in i+1..<copyArr.count{
                if copyArr[minIndex] > copyArr[j]{
                    minIndex = j
                }
            }
            
            copyArr.swapAt(i, minIndex)
            
            print("insertSort count:\(i) , array : \(copyArr)")
        }
        
        return copyArr
    }
    
    //선택정렬 . 왼쪽을 기준으로 비교해서 왼쪽으로 보내는것
    func selectSort<T:Comparable>(origin:[T]) -> [T]{
        var copyArr = origin
        
        for i in 1..<copyArr.count{
            var j = i
            
            while(j>0 && copyArr[j] < copyArr[j-1]){
                copyArr.swapAt(j, j-1)
                print("selectSort array : \(copyArr)")
                j -= 1
            }
        }
        
        return copyArr
    }
    
    //버블정렬 왼쪽 + 오른쪽을 묶어서 비교 하고 작은것을 왼쪽으로 보냄 결국 가장 큰게 for문 한번에 하나씩 뒤로 가게 되는 것임
    //그래서 뒤쪽은 하나씩 줄여 나가야 함
    func bubbleSort<T:Comparable>(origin:[T]) -> [T]{
        var copyArr = origin
        
        for i in 0..<copyArr.count{
            var isSwap = false
            for j in 0..<copyArr.count - 1 - i{
                if copyArr[j] > copyArr[j+1]{
                    copyArr.swapAt(j, j+1)
                    isSwap = true
                    print("bubbleSort count:\(i) , array : \(copyArr)")
                }
            }
            
            if isSwap == false{
                break
            }
            
        }
        
        return copyArr
    }
    
    //퀵 정렬
//    기준점(pivot)을 정해서, 기준점보다 작은 데이터는 왼쪽(left), 큰 데이터는 오른쪽(right)으로 모음
//    ② 위에서 모은 왼쪽(left), 오른쪽(right)의 갯수가 1개 이하가 될 때까지 위 작업을 재귀로 반복함
//    ③ 재귀 함수는 왼쪽(left) + 기준점(pivot) + 오른쪽(right) 을 리턴함
    func quickSort<T:Comparable>(arr:[T]) -> [T]{
        print("quickSort arr : \(arr)")
        guard let pivot = arr.first, arr.count > 1 else { return arr }
        
        let leftArr = arr.filter{ $0<pivot}
        let rightArr = arr.filter{ $0>pivot}
        
        return quickSort(arr: leftArr) + [pivot] + quickSort(arr: rightArr)
    }
    
    //합병정렬 merge sort
    //① 배열을 절반으로 잘라, 두 배열로 나눔 (배열의 갯수가 7같이 홀수일 경우, 3개&4개로 나눔)
    //② 배열의 갯수가 1개 이하일 때까지 위 작업을 재귀함수로 반복함
    //③ 재귀 함수는 나눠진 두 배열을 합병 정렬을 이용해 정렬하고 리턴함
    //위 그림처럼 두 배열을 0번 index부터 비교하며,
    //작은 값부터 나열하는 것을 합병 정렬이라고 함
    //왼쪽 배열의 0번 Index가 작으면 왼쪽 배열의 0번 index를 나열하고,
    //이제 왼쪽 배열의 1번 index와 오른쪽 배열의 0번 index를 비교하는 것임
    //이런 식으로 두 배열의 전체 값을 정렬하는 것이 합병 정렬!
    func mergeSort<T:Comparable>(arr:Array<T>) -> Array<T>{
        print("mergeSort arr : \(arr)")

        if arr.count <= 1 { return arr }
        
        let leftArr = Array(arr[0..<arr.count/2])
        let rightArr = Array(arr[arr.count/2..<arr.count])
        
        return merge(left: mergeSort(arr: leftArr), right: mergeSort(arr: rightArr))
    }
    
    func merge<T:Comparable>(left:Array<T>,right:Array<T>) -> Array<T>{
        var left = left
        var right = right
        var result: [T] = []

        while !left.isEmpty && !right.isEmpty {
            if left[0] < right[0] {
                result.append(left.removeFirst())
            } else {
                result.append(right.removeFirst())
            }
        }
        
        // 왼쪽 배열의 요소가 남은 경우
        if !left.isEmpty {
            result.append(contentsOf: left)
        }
        
        // 오른쪽 배열의 요소가 남은 경우
        if !right.isEmpty {
            result.append(contentsOf: right)
        }
        
        return result
    }

